# 开闭原则

## 概念

1. 如何理解“对扩展开放、对修改关闭”？

添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。关于定义，我们有两点要注意。第一点是，开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。第二点是，同样的代码改动，在粗代码粒度下，可能被认定为“修改”；在细代码粒度下，可能又被认定为“扩展”。

2. 如何做到“对扩展开放、修改关闭”？

我们要时刻具备扩展意识、抽象意识、封装意识。在写代码的时候，我们要多花点时间思考一下，这段代码未来可能有哪些需求变更，如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，在不改动代码整体结构、做到最小代码改动的情况下，将新的代码灵活地插入到扩展点上。

很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的的。特别是 23 种经典设计模式，大部分都是为了解决代码的扩展性问题而总结出来的，都是以开闭原则为指导原则的。最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态）

## 例子

这里是一个报警模块的设计，当服务器 io, memory 异常时会报警。如果代码如下，逻辑堆积在一个方法里检查，在新增功能如 cpu 检查时，将会修改 check 函数的逻辑。

```js
function alert(){
    if(io > 5){}
    if(memory > 10){}
    if(cpu > 20){}
}
```

可以修改为下面逻辑。

```js
const IO = {
    max: 10,
    check(statInfo){
        if(this.statInfo > this.max){
            // 报警
        }
    }
}
function alert(handlers, statInfo){
    for(let i = 0; i < handlers.length; i++){
        handlers[i].check(statInfo)
    }
}
alert([IO, Memory, CPU])
```

修改后的代码通过开闭原则进行了解耦，使得扩展性更好，代码更内聚。在新增 CPU 功能时，只需要在 alert 里新增一个要检查的 CPU 模块，再扩展一个 CPU.check 即可，不用修改之前的代码逻辑。

最后可以将上面代码修改为面向对象的方式：[查看最终代码](./demo.js)

